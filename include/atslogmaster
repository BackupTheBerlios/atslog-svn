#!/bin/sh
# ATSlog version @version@ build @buildnumber@ www.atslog.dp.ua
# Copyright (C) 2003 Denis CyxoB www.yamiyam.dp.ua
#                                                       
PATH=/sbin:/usr/sbin:/bin:/usr/bin:/usr/local/sbin:/usr/local/bin:.
NOWDATE=`LANG=en_US;date`
BASENAME=`basename $0`

# Readin config file                              
if [ -r /usr/local/etc/atslog.conf ]; then
    . /usr/local/etc/atslog.conf

# Переменную $LANG - берём из настройки локали.
    if [ -f $sharedir/$langdir/$LANG ]; then
	. $sharedir/$langdir/$LANG
    elif [ -f $sharedir/$langdir/en_US ]; then
	. $sharedir/$langdir/en_US
    else
	echo "Can't open language file"
	exit 1
    fi
else
    echo "Can't open config file"
    exit 1
fi                                                

# Установим рабочие переменные
PATH=$PATH:$bindir:$sharedir
if [ -s $pidfile ];then
    GROUPPid=`cat $pidfile`
    if [ -z "$GROUPPid" ];then
        GROUPPid=`ps xo pgid,command | grep "$bindir/$atslogd" | grep --invert-match grep | head -1 | awk '{print $1}'`
    fi
else
    GROUPPid=`ps xo pgid,command | grep "$bindir/$atslogd" | grep --invert-match grep | head -1 | awk '{print $1}'`
fi

case "$debug" in
    [Yy][Ee][Ss])
        notwriteoutput="$logdir/$notwritelog"
    ;;
    *)
        notwriteoutput="/dev/null"
    ;;
esac

# Проверим, используется tcp порт, или порт в /dev/
TCPPORT=$(expr $port : "\.*tcp:.*\$")
if [ $TCPPORT = 0 ];then
    port="/dev/"${port}
fi

# Определим основные функции
#
# Функция выводит сообщения об ошибках на консоль, в лог-файл и в syslog
echomess(){
    if [ ! -z "$GROUPPid"  ];then
	ECHOGROUPPid="[${GROUPPid}]"
    else
	ECHOGROUPPid=""
    fi
    if [ -n "$ECHOMESSAGE" ];then
	MESSAGE=$ECHOMESSAGE
    else
	MESSAGE=$ERRORMESSAGE
	logger -p $syslogfacility "${masterscript}${ECHOGROUPPid}: $MESSAGE"
    fi
    echo "${masterscript}: $MESSAGE"
    echo "$NOWDATE ${masterscript}${ECHOGROUPPid}: $MESSAGE" >> $logdir/$startlogfile
    ECHOMESSAGE=""
    ERRORMESSAGE=""
}

func_restart(){
# Останавливаем.
    stoploging 
    if [ $? -eq 0 ]
    then
# Если удалось успешно остановить, то запускаем заново.
        startloging
        if [ $? -eq 0 ]
	then
	    echo "$msg9"
	else
	    echo "$msg23"
	    exit 1
	fi
    else
	echo "$msg8"
	exit 1
    fi
}

# Функция запускает основной скрипт считывания информации из мини-АТС
startloging(){
    if [ -s $pidfile ];then
    	ECHOMESSAGE=$msg1
	echomess
	TORETURN=1
    else
	# Проверим, заканчивается ли наши текстовые лог-файлы пустой строкой.
	# Нужно для того, чтобы последние строки не слились в одну.
	# Такое может случиться, например, при некорректном
        # завершения роботы программы или при выключении питания
        # в момент записи строки.
        # В любом случае новая строка не помешает! :)

	for textlog in $curcallslogfile $callslogfile
	do
    	    if [ -s $logdir/$textlog ];then
		LASTSTRING=`tail -n1 $logdir/$textlog`
		if [ -n "$LASTSTRING" ];then
    		    echo "" >> $logdir/$textlog
		fi
    	    else
		touch $logdir/$textlog
	    fi
	done

	# Запустим считывание
	case "$fastwrite" in
	    [Yy][Ee][Ss])
		case "$debug" in
		    [Yy][Ee][Ss])
	    		$bindir/$atslogd -P $pidfile -o -f $stopbits -p $parity -c $charsize -s $speed -D $logdir -F $callslogfile -L $logdir/$startlogfile $port | $bindir/$atslogdb 1>> $logdir/$notwritelog 2>/dev/null &
			TORETURN=$?
		    ;;
		    *)
			$bindir/$atslogd -P $pidfile -o -f $stopbits -p $parity -c $charsize -s $speed -D $logdir -F $callslogfile -L $logdir/$startlogfile $port | $bindir/$atslogdb 1>/dev/null 2>/dev/null &
			TORETURN=$?
		    ;;
		esac
	    ;;
	    *)
		case "$debug" in
		    [Yy][Ee][Ss])
			$bindir/$atslogd -P $pidfile -o -f $stopbits -p $parity -c $charsize -s $speed -D $logdir -F $curcallslogfile -L $logdir/$startlogfile $port 1>> $logdir/$notwritelog 2>/dev/null &
			TORETURN=$?
		    ;;
		    *)
			$bindir/$atslogd -P $pidfile -f $stopbits -p $parity -c $charsize -s $speed -D $logdir -F $curcallslogfile -L $logdir/$startlogfile $port 1>/dev/null 2>/dev/null &
			TORETURN=$?
		    ;;
		esac
	    ;;
	esac
    fi
    return $TORETURN
}

# Функция останавливает основной скрипт считывания информации из мини-АТС
stoploging(){
    if [ -s $pidfile ];then
	KILLGROUPPid=`cat $pidfile`
    fi

    if [ -z "$KILLGROUPPid" ];then
	KILLGROUPPid="$GROUPPid"
    fi
    if [ -n "$KILLGROUPPid" ];then
	if [ -f $pidfile ];then
	    rm -f $pidfile
	fi
	kill -- -$KILLGROUPPid 1>/dev/null 2>/dev/null
	RETURNKILL=$?
	if [ $RETURNKILL -eq 0 ]
	then
            echo "$NOWDATE ${atslogd}[$KILLGROUPPid]: $msg2" >> $logdir/$startlogfile
	    return 0
	else
	    echo $KILLGROUPPid > $pidfile
	    ERRORMESSAGE=$msg3
	    echomess
	    return $RETURNKILL
	fi
    else
	ERRORMESSAGE=$msg4
	echomess
	return 1
    fi
}

case "$1" in
start)
    startloging
    if [ $? -eq 0 ]
    then
	echo "$msg5"
    else
	echo "$msg23"
	exit 1
    fi
    ;;
stop)
    stoploging
    if [ $? -eq 0 ]
    then
	echo "$msg7"
    else
	echo "$msg8"
	exit 1
    fi
    ;;
restart)
    func_restart
    ;;
reload)
    # Reload
    if [ -n "$GROUPPid" ];then
        kill -HUP $GROUPPid
    fi
    ;;
writedb)
    # Запись данных в базу SQL сервера

    # Будем записывать данные только в том случае,
    # если $curcallslogfile не пустой.
	if [ -s $logdir/$curcallslogfile ];then
	    case "$fastwrite" in
	        [Yy][Ee][Ss])
		    if [ -n "$GROUPPid" ];then
			
			echo "$msg24"
			exit 1
		    fi
	    esac
	    echo "$msg11"

	    # Переименуем текущий, открытый для записи файл во временный.
	    mv $logdir/$curcallslogfile $logdir/$curcallslogfile.tmp
	    # Сообщим демону, что нужно пересоздать текстовый лог-файл.
	    TORETURN=0
	    if [ -n "$GROUPPid" ];then
		kill -HUP $GROUPPid
		TORETURN=$?
	    else
		touch $logdir/$curcallslogfile
	    fi

	    if [ $TORETURN -eq 0 ]
	    then
		ECHOMESSAGE=$msg12
		echomess

# Call to script atslogdb.pl
		cat $logdir/$curcallslogfile.tmp 2>/dev/null | $bindir/$atslogdb 1>> $notwriteoutput 2>/dev/null
    		if [ $? -eq 0 ]
		then
		    cat $logdir/$curcallslogfile.tmp >> $logdir/$callslogfile
		    if [ $? -eq 0 ]
		    then
    			rm $logdir/$curcallslogfile.tmp
			ECHOMESSAGE=$msg13
			echomess
		    else
    			ECHOMESSAGE=$msg34
			echomess
			ECHOMESSAGE=$msg35
			echomess
			exit 1
		    fi
		else
		    ECHOMESSAGE=$msg34
		    echomess
		    ECHOMESSAGE=$msg28
		    echomess
		    exit 1
		fi
	    else
		# Т.к. затея не удалась, то вернём файлу прежнее имя,
		# предварительно проверив, нет ли на его месте старого!
		if [ ! -s $logdir/$curcallslogfile -a -s $logdir/$curcallslogfile.tmp ];then
		    mv $logdir/$curcallslogfile.tmp $logdir/$curcallslogfile
		fi
		ERRORMESSAGE=$msg25
		echomess
		exit 1
	    fi
	else
	    ECHOMESSAGE=$msg14
    	    echomess
        fi
    ;;
rotate)
    # Log rotate

    if [ $howmonth -gt 1 ];then
    # Rotating
	    echo "$msg15"
	    echo -n "$msg16"
    	    i=$howmonth
    	    while [ $i -ge 1 ]
	    do
		for logf in $callslogfile $notwritelog $startlogfile
		do
    	    	    if [ -s $logdir/$logf ];then
    	    		if [ -r $logdir/$logf.$i.bz2 ];then
			    nextM=$(($i+1))
			    if [ $nextM -le $howmonth ];then
				mv $logdir/$logf.$i.bz2 $logdir/$logf.$nextM.bz2 ; echo -n "."
			    fi
			fi
		    fi
		done
		i=$(($i-1))
	    done
	    echo " $msg17"

	    echo -n "$msg18"

	    # Если файл есть, и не пустой
	    if [ -s $logdir/$callslogfile ];then
		# Переименуем текущий, открытый для записи файл во временный.
		mv $logdir/$callslogfile $logdir/$callslogfile.tmp
		# Сообщим демону, что нужно пересоздать текстовый лог-файл.
		if [ -n "$GROUPPid" ];then
		    kill -HUP $GROUPPid
		else
		    touch $logdir/$callslogfile
		fi

		echo "$NOWDATE ${masterscript}[$GROUPPid]: $callslogfile rotate" >> $logdir/$startlogfile
		bzip2 -z $logdir/$callslogfile.tmp
		mv $logdir/$callslogfile.tmp.bz2 $logdir/$callslogfile.1.bz2
	        echo -n "."
	    fi

	    for logfn in $notwritelog $startlogfile
	    do
		if [ -s $logdir/$logfn ];then
		    echo "$NOWDATE ${masterscript}[$GROUPPid]: $logfn rotate" >> $logdir/$startlogfile
		    bzip2 -z $logdir/$logfn
		    mv $logdir/$logfn.bz2 $logdir/$logfn.1.bz2

		    touch $logdir/$logfn
		    echo -n "."
		fi
	    done
	    echo " $msg17"
    else
	echo "$msg19"
    fi
    ;;
alltodb)
    # Экспортирование информации из всех текстовых лог-файлов (включая
    # архивированные) в базы SQL сервера.
    echo "$msg20"
    echo -n "$msg21"
    i=$howmonth
    LASTERROR=0
    while [ $i -ge 1 ]
    do
	if [ -s $logdir/$callslogfile.$i.bz2 ];then
	    bzcat $logdir/$callslogfile.$i.bz2 | $bindir/$atslogdb 1>> $notwriteoutput
	    if [ $? -eq 0 ]
	    then
		echo -n "."
	    else
		LASTERROR=1
	    fi
	fi
	i=$(($i-1))
    done

    if [ -s $logdir/$callslogfile ];then
	cat $logdir/$callslogfile | $bindir/$atslogdb 1>> $notwriteoutput
	if [ $? -eq 0 ]
	then
	    echo -n "."
	else
	    LASTERROR=1
	fi
    fi

    if [ -s $logdir/$curcallslogfile ];then
	cat $logdir/$curcallslogfile | $bindir/$atslogdb 1>> $notwriteoutput
	if [ $? -eq 0 ]
	then
	    echo -n "."
	else
	    LASTERROR=1
	fi
    fi
    if [ $LASTERROR -eq 0 ]
    then                
        echo " $msg17"
    else                
        echo "$msg23"
    fi                  
    ;;
cleardb)
    # Очистить таблицу SQL сервера
    #
    $bindir/$cleardb yes
    ;;
*)
    echo "atslogmaster version @version@ build @buildnumber@"
    if [ -n "$GROUPPid" ];then
	echo "$atslogd $msg26 $GROUPPid"
    else
	echo "$atslogd $msg27"
	EXITSTATUS=1
    fi
    echo "Usage: $BASENAME {start|stop|restart|reload|writedb|rotate|alltodb|cleardb}"
    ;;
esac
exit $EXITSTATUS
